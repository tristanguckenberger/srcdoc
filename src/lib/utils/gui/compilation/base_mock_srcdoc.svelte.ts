import BaseScreenLVL from '../presets/projectObject.svelte.ts';
import GameObject from '../presets/gameObject.svelte.ts';
import StaticObject from '../presets/staticObject.svelte.ts';
import DynamicObject from '../presets/dynamicObject.svelte.ts';

/**
 * Serializes a function definition into a string.
 * @param funcDef - The func definition
 * @returns The serialized func as a string
 */
const serializeFunc = (funcDef: Function): string => {
	return funcDef.toString();
};

/**
 *
 * @param config
 * @param gameId
 * @param parentFileId
 * @param fileId
 * @returns {FileObject}
 */
function generateClassFileFromJSON(
	config: ClassTemplate,
	game_id: number,
	parent_file_id: number,
	fileId: number | null
): FileObject {
	const { className, baseClass, properties, methods } = config;

	// Build the properties
	const propertyCode = Object.entries(properties)
		.map(([key, value]) => {
			const defaultValue = typeof value === 'string' ? `'${value}'` : value;
			return `this.${key} = props.${key} || ${defaultValue};`;
		})
		.join('\n\t\t');

	// Build the methods
	const methodCode = Object.entries(methods)
		.map(([methodName, method]) => {
			const {
				params = [],
				body,
				static: isStatic = false,
				getter = false,
				setter = false
			} = method;

			// Build getter
			if (getter) {
				return `
    get ${methodName}() {
      ${body}
    }
        `;
			}

			// Build setter
			if (setter) {
				const paramList = params.join(', '); // Usually one parameter, e.g., ["value"]
				return `
    set ${methodName}(${paramList}) {
      ${body}
    }
        `;
			}

			// Build static or regular methods
			const paramList = params.join(', ');
			return `
		  ${isStatic ? 'static ' : ''}${methodName}(${paramList}) {
			${body}
		  }
			  `;
		})
		.join('\n');

	// Generate the class code
	const classCode = `
	class ${className} extends ${baseClass} {
	  constructor(props) {
		super({ ...props });
		${propertyCode}
	  }
	  ${methodCode}
	}

	window.addEventListener('load', () => {
		const canvas = document.getElementById('gameCanvas');
		const dpr = window.devicePixelRatio || 1;
		canvas.width = window.innerWidth * dpr;
		canvas.height = window.innerHeight * dpr;
		canvas.style.width = \`\${window.innerWidth}px\`;
		canvas.style.height = \`\${window.innerHeight}px\`;

		const game = new StarterScreen({ canvas });
		game.initialize(ctx);

		// Start the game loop
		game.startGameLoop(ctx);

	});
	`;

	// Return the object in the desired format
	return {
		id: fileId, // Pass in the file ID
		game_id: game_id, // The project ID
		parent_file_id: parent_file_id, // Parent file ID (root folder)
		name: className.toLowerCase(), // Use the class name as the file name, in lowercase
		type: 'js', // File type
		content: classCode.trim(), //.replace(/\n/g, '\\n'), // Flatten the class code with '\n',
		created_at: null,
		updated_at: null
	};
}

/**
 * Generates the base files and a starter game/screen file.
 * id should be blank, as it will be generated by the database.
 * @returns {FileObject[]}
 */
function getBaseFiles(gameId: number, rootFileId: number): FileObject[] {
	// Define the root folder
	// const rootFolder: FileObject = {
	// 	id: 20,
	// 	game_id: 1, // Assuming game_id is 1 for this context
	// 	parent_file_id: 1,
	// 	name: 'root_test',
	// 	type: 'folder',
	// 	content: null, // Folders don't have content
	// 	created_at: new Date().toISOString(),
	// 	updated_at: new Date().toISOString()
	// };

	// Base class files
	const baseFiles: FileObject[] = [
		{
			id: null,
			game_id: gameId,
			parent_file_id: rootFileId, // Under root folder
			name: 'gameObject',
			type: 'js',
			content: serializeFunc(GameObject),
			created_at: new Date().toISOString(),
			updated_at: new Date().toISOString()
		},
		{
			id: null,
			game_id: gameId,
			parent_file_id: rootFileId, // Under root folder
			name: 'staticObject',
			type: 'js',
			content: serializeFunc(StaticObject),
			created_at: new Date().toISOString(),
			updated_at: new Date().toISOString()
		},
		{
			id: null,
			game_id: gameId,
			parent_file_id: rootFileId, // Under root folder
			name: 'dynamicObject',
			type: 'js',
			content: serializeFunc(DynamicObject),
			created_at: new Date().toISOString(),
			updated_at: new Date().toISOString()
		}
	];

	// Generate starter game/screen file
	const starterScreenFile: FileObject = generateClassFileFromJSON(
		{
			className: 'StarterScreen',
			baseClass: 'BaseScreenLVL',
			properties: {
				width: 800,
				height: 600,
				canvas: null, // Canvas instance passed at runtime
				backgroundColor: '#000000'
			},
			methods: {
				initialize: {
					params: ['context'],
					body: `
            console.log('Initializing Starter Screen');
          `
				},
				draw: {
					params: [],
					body: `
            if (!this.canvas) {
              console.error('Canvas instance is not set.');
              return;
            }
            this.context.fillStyle = this.backgroundColor;
            this.context.fillRect(0, 0, this.width, this.height);
            console.log('Drawing Starter Screen');
          `
				},
				setCanvas: {
					params: ['canvas'],
					body: `
            this.canvas = canvas;
            console.log('Canvas instance set:', canvas);
          `
				},
				startGameLoop: {
					params: ['canvas'],
					body: `
					let lastTimestamp = 0;
			
					const gameLoop = (timestamp) => {
						const deltaTime = (timestamp - lastTimestamp) / 1000; // Calculate delta time in seconds
						lastTimestamp = timestamp;
			
						// Clear the canvass
						context.clearRect(0, 0, this.canvas.width, this.canvas.height);
			
						// Call update and draw methods
						this.update(deltaTime);
						this.draw(context);
			
						if (this.running) {
							requestAnimationFrame(gameLoop);
						}
					};
			
					requestAnimationFrame(gameLoop);
					`
				},
				update: {
					params: ['deltaTime'],
					body: `console.log('Updating Starter Screen');`
				}
			}
		},
		gameId, // game_id
		rootFileId, // parent_file_id (root folder)
		null // File ID for the starter screen
	);

	// base files, and starter screen
	return [...baseFiles, starterScreenFile];
}

/**
 * This function retrieves a file by its ID.
 *
 * @param files - Array of FileObject
 * @param id - ID of the file to retrieve
 * @returns A FileObject or an ErrorObject
 */
const findFileById = (files: FileObject[], id: number): FileObject | ErrorObject => {
	if (!files || files.length === 0) {
		return { errorMessage: 'No files found!' };
	}

	if (!id) {
		return { errorMessage: 'No id provided!' };
	}

	return files.find((file) => file.id === id) ?? { errorMessage: `No file found with id ${id}!` };
};

/**
 * This function retrieves the children belonging to a file using its ID.
 *
 * @param files - Array of FileObject
 * @param parentId - ID of the parent file
 * @returns An array of FileObject or an ErrorObject
 */
const findChildren = (files: FileObject[], parentId: number): FileObject[] | ErrorObject => {
	if (!files || files.length === 0) {
		return { errorMessage: 'No files found!' };
	}

	if (!parentId) {
		return { errorMessage: 'No parentId provided!' };
	}

	const childrenFound = files.filter((file) => file.parent_file_id === parentId);

	return childrenFound.length > 0
		? childrenFound
		: { errorMessage: `No children found for file with id ${parentId}!` };
};

/**
 * This function recursively collects files under a root folder.
 *
 * @param files - Array of FileObject
 * @param rootId - ID of the root file
 * @param collected - Accumulator for collected files
 * @returns An array of FileObject or an ErrorObject
 */
const collectFiles = (
	files: FileObject[],
	rootId: number | null = 1,
	collected: FileObject[] = []
): FileObject[] | ErrorObject => {
	if (!files || files.length === 0) {
		return { errorMessage: 'No files found!' };
	}

	if (!rootId) {
		return { errorMessage: 'No rootId provided!' };
	}

	const rootFile = findFileById(files, rootId);
	if ('errorMessage' in rootFile) {
		return rootFile; // Propagate the error
	}

	if (rootFile.type === 'folder') {
		const children = findChildren(files, rootId);
		if (Array.isArray(children)) {
			children.forEach((child) => collectFiles(files, child.id, collected));
		}
	}

	collected.push(rootFile);
	return collected;
};

/**
 * This function resolves dependencies in a file.
 *
 * @param file - A FileObject
 * @returns The content of the file or an ErrorObject
 */
const resolveDependencies = (file: FileObject): string | ErrorObject => {
	if (!file) {
		return { errorMessage: 'No file provided!' };
	}

	return file.content ?? '';
};

/**
 * Generates the `srcdoc` for the iframe, embedding base class definitions.
 * @param files - Array of FileObject
 * @param clientDimensions - Dimensions of the client
 * @returns A srcdoc string or an ErrorObject
 */
const generateSrcDoc = (
	files: FileObject[],
	clientDimensions: ClientDimensionsObject
): string | ErrorObject => {
	if (!files || files.length === 0) {
		return { errorMessage: 'No files provided!' };
	}

	let htmlContent = '';
	let cssContent = '';
	let jsContent = '';

	files.forEach((file) => {
		const resolvedContent = resolveDependencies(file);
		if (typeof resolvedContent !== 'string') return; // Skip if there's an error

		if (file.type === 'html') {
			htmlContent += resolvedContent;
		} else if (file.type === 'css') {
			cssContent += `<style>${resolvedContent}</style>`;
		} else if (file.type === 'js') {
			jsContent += `${resolvedContent}\n`;
		}
	});

	// Serialize Base Classes
	const baseClasses = `
	  ${serializeFunc(BaseScreenLVL)}
	`;

	// Combine base classes and user JS content
	const jsContentWithBaseClasses = `
	  ${baseClasses}
	  ${jsContent}
	`;

	const getWidth = () => clientDimensions.width;
	const getHeight = () => clientDimensions.height;

	const srcdoc = `
	  <!DOCTYPE html>
	  <html>
		<head>
		  ${cssContent}
		</head>
		<body style="width: ${getWidth()}px; height: ${getHeight()}px;">
		  ${htmlContent}
		  <script>
			${jsContentWithBaseClasses}
		  </script>
		</body>
	  </html>
	`;

	return srcdoc.trim();
};

/**
 * This function builds the srcdoc.
 *
 * @param files - Array of FileObject
 * @param rootId - ID of the root file
 * @param clientDimensions - Dimensions of the client
 * @returns A srcdoc string or an ErrorObject
 */
const buildDynamicSrcDoc = (
	files: FileObject[],
	rootId: number,
	clientDimensions: ClientDimensionsObject
): string | ErrorObject => {
	if (!files || files.length === 0) {
		return { errorMessage: 'No files provided!' };
	}

	if (!rootId) {
		return { errorMessage: 'No rootId provided!' };
	}

	const relevantFiles = collectFiles(files, rootId);

	if ('errorMessage' in relevantFiles) {
		return relevantFiles;
	}

	return generateSrcDoc(relevantFiles, clientDimensions);
};

/**
 * This function builds a screen group.
 *
 * @param gameData - The game data (see `lib/mockData/guiGameData.js` for an example)
 * @returns A record of screen groups or an ErrorObject
 */
const buildScreenGroup = (gameData: {
	screens: { id: number; type: string }[];
}): Record<number, number[]> => {
	const screenGroup: Record<number, number[]> = {};

	// Get all lvl screens
	const lvlScreens = gameData.screens.filter((screen) => screen.type === 'lvl');

	lvlScreens.forEach((lvlScreen) => {
		// Find all associated UI screens (ignoring type `lvl`)
		const associatedUIScreens = gameData.screens.filter((screen) => screen.type === 'ui');

		// Store them in screenGroup
		screenGroup[lvlScreen.id] = [lvlScreen.id, ...associatedUIScreens.map((ui) => ui.id)];
	});

	return screenGroup;
};

export {
	getBaseFiles,
	generateClassFileFromJSON,
	findFileById,
	findChildren,
	collectFiles,
	generateSrcDoc,
	buildDynamicSrcDoc,
	buildScreenGroup
};
